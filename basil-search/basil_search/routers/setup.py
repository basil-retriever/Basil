from fastapi import APIRouter, HTTPException, BackgroundTasks
from fastapi.responses import HTMLResponse
from pydantic import BaseModel, HttpUrl
from typing import Optional
import os
import json
from pathlib import Path
import logging
import asyncio

from basil_search.src.config import Config
from basil_search.pipeline import WebsitePipeline

logger = logging.getLogger(__name__)

router = APIRouter()

class SetupRequest(BaseModel):
    groq_key: str
    website_url: HttpUrl
    allowed_origins: str = "*"
    max_pages: int = 50
    internal_site: bool = False

class SetupResponse(BaseModel):
    message: str
    status: str
    website_url: str
    indexing_started: bool = False

def save_configuration(setup_data: SetupRequest):
    """Save configuration to .env file and config files"""
    
    # Create .env file with the configuration
    env_content = f"""# Basil Configuration - Generated by Setup
GROQ_API_KEY={setup_data.groq_key}
ALLOWED_ORIGINS={setup_data.allowed_origins}
HOST=0.0.0.0
PORT=8000
"""
    
    # Write to .env file in the working directory
    env_path = Path.cwd() / ".env"
    with open(env_path, "w") as f:
        f.write(env_content)
    
    # Also save a config file for future reference
    config_data = {
        "website_url": str(setup_data.website_url),
        "allowed_origins": setup_data.allowed_origins,
        "max_pages": setup_data.max_pages,
        "internal_site": setup_data.internal_site,
        "setup_completed": True
    }
    
    config_path = Path.cwd() / "basil_config.json"
    with open(config_path, "w") as f:
        json.dump(config_data, f, indent=2)
    
    # Update environment variables for current session
    os.environ["GROQ_API_KEY"] = setup_data.groq_key
    os.environ["ALLOWED_ORIGINS"] = setup_data.allowed_origins
    
    return config_path

async def run_indexing_pipeline(setup_data: SetupRequest):
    """Run the indexing pipeline in the background"""
    try:
        logger.info(f"Starting background indexing for {setup_data.website_url}")
        
        # Initialize pipeline
        pipeline = WebsitePipeline()
        
        # Run the complete pipeline
        results = pipeline.run_pipeline(
            url=str(setup_data.website_url),
            max_pages=setup_data.max_pages,
            scrape=True,
            process=True,
            load=True,
            serve=False,  # Don't start server in background task
            internal=setup_data.internal_site
        )
        
        logger.info(f"Indexing completed for {setup_data.website_url}: {results}")
        
        # Mark indexing as completed
        config_path = Path.cwd() / "basil_config.json"
        if config_path.exists():
            with open(config_path, "r") as f:
                config_data = json.load(f)
            
            config_data["indexing_completed"] = True
            config_data["indexing_results"] = results
            
            with open(config_path, "w") as f:
                json.dump(config_data, f, indent=2)
        
    except Exception as e:
        logger.error(f"Background indexing failed: {e}")
        
        # Mark indexing as failed
        config_path = Path.cwd() / "basil_config.json"
        if config_path.exists():
            with open(config_path, "r") as f:
                config_data = json.load(f)
            
            config_data["indexing_failed"] = True
            config_data["indexing_error"] = str(e)
            
            with open(config_path, "w") as f:
                json.dump(config_data, f, indent=2)

@router.get("", response_class=HTMLResponse)
async def setup_page():
    """Serve the setup page HTML"""
    
    # Check if already configured
    config_path = Path.cwd() / "basil_config.json"
    if config_path.exists():
        with open(config_path, "r") as f:
            config_data = json.load(f)
        
        if config_data.get("setup_completed"):
            # If already set up, show status or redirect to docs
            return HTMLResponse(f"""
            <!DOCTYPE html>
            <html>
            <head>
                <title>Basil - Already Configured</title>
                <meta http-equiv="refresh" content="3;url=/docs">
                <style>
                    body {{ 
                        font-family: Arial, sans-serif; 
                        text-align: center; 
                        padding: 50px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                    }}
                    .container {{ 
                        background: white; 
                        color: #333; 
                        padding: 40px; 
                        border-radius: 12px; 
                        display: inline-block;
                        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
                    }}
                </style>
            </head>
            <body>
                <div class="container">
                    <h1>ðŸŒ¿ Basil is Already Configured</h1>
                    <p>Website: {config_data.get("website_url", "Unknown")}</p>
                    <p>Redirecting to API documentation...</p>
                    <p><a href="/docs">Click here if not redirected automatically</a></p>
                </div>
            </body>
            </html>
            """)
    
    # Read and return the setup HTML template
    template_path = Path(__file__).parent.parent / "templates" / "setup.html"
    
    try:
        with open(template_path, "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Setup template not found")

@router.post("", response_model=SetupResponse)
async def setup_basil(setup_data: SetupRequest, background_tasks: BackgroundTasks):
    """Handle setup form submission and start indexing"""
    
    try:
        # Validate Groq API key format (basic validation)
        if not setup_data.groq_key or len(setup_data.groq_key) < 10:
            raise HTTPException(
                status_code=400,
                detail="Invalid Groq API key. Please check your API key."
            )
        
        # Save configuration
        config_path = save_configuration(setup_data)
        logger.info(f"Configuration saved to {config_path}")
        
        # Test Groq API connection
        try:
            from basil_search.src.utils import GroqClient
            client = GroqClient()
            if not client.test_connection():
                raise HTTPException(
                    status_code=400,
                    detail="Failed to connect to Groq API. Please check your API key."
                )
        except Exception as e:
            logger.warning(f"Could not test Groq connection: {e}")
        
        # Start background indexing
        background_tasks.add_task(run_indexing_pipeline, setup_data)
        
        return SetupResponse(
            message=f"Basil setup completed! Indexing started for {setup_data.website_url}. This process will continue in the background.",
            status="success",
            website_url=str(setup_data.website_url),
            indexing_started=True
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Setup failed: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Setup failed: {str(e)}"
        )

@router.get("/status")
async def setup_status():
    """Get the current setup and indexing status"""
    
    config_path = Path.cwd() / "basil_config.json"
    
    if not config_path.exists():
        return {
            "setup_completed": False,
            "indexing_completed": False,
            "message": "Setup not started"
        }
    
    with open(config_path, "r") as f:
        config_data = json.load(f)
    
    status = {
        "setup_completed": config_data.get("setup_completed", False),
        "website_url": config_data.get("website_url"),
        "indexing_completed": config_data.get("indexing_completed", False),
        "indexing_failed": config_data.get("indexing_failed", False),
    }
    
    if config_data.get("indexing_completed"):
        status["message"] = "Setup and indexing completed successfully"
        status["indexing_results"] = config_data.get("indexing_results")
    elif config_data.get("indexing_failed"):
        status["message"] = f"Indexing failed: {config_data.get('indexing_error')}"
    else:
        status["message"] = "Setup completed, indexing in progress"
    
    return status